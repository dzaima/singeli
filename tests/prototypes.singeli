safe_double{T} (x:T) {
  y:2*T = Cast{2*T}(x);
  y + y
}

safe_double{f64} (x:f64) => x+x


mulvv{T,S | S<T}(n:Size, z:*T, w:*S, x:*T) : Size {
  autofor (w, x, z; i to n) { // w,x and z now become vectors of unknown, but equal length, possibly different between iterations (aka k∊1…∞; w:[k]S; x:[k]T; z:[k]T)
    z = Cast{T}(w) *@{return i;} x;
  }
  n
}

mulvv_over{T,S,O | S<T & O>T}(n:Size, z:*O, w:*S, x:*T) : Size {
  autofor (w, x, z; i to n) {
    z = Cast{O}(w) * Cast{O}(x);
  }
  n
}

mulvv{T,S | S<T}(n:Size, z:*T, w:*S, x:*T) : Size {
  for_scal{T} w, x, z over i in n {
    z = Cast{T}(w) *@{return i} x
  }
  n
}

mulvv_over{T,S,O | S<T & O>T}(n:Size, z:*O, w:*S, x:*T) : Size {
  for_scal{O} w, x, z over n {
    z = Cast{O}(w) * Cast{O}(x)
  }
  n
}