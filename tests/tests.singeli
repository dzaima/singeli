g{T,n}(a:T) {
  x:T = n+a;
  x
}
'ok1' = g{i32, 5};
'ok2' = g{i32, 1*2 + 3*4};

addSep{A,B}(a:A, b:B) : A {
  a+b
}
'ok3' = addSep{i32,i32};
'i32Plusi64' = addSep{i32,i64};
'wrongTargCount' = addSep{i32};

h1{T,n}(a:[n]T, b:[n]T) : [n]T => a + b;
'ok4' = h1{i32,4};

mismatchedVectorSize{A,B}(a:A, b:B) => a + b;
'mismatchedVectorSize' = mismatchedVectorSize{[4]i32, [8]i32};

vecOfVecs{T}(a:[4]T) { }
'vecOfVecs' = vecOfVecs{[2]i32};

recursion() { recursion(); }
'recursion' = recursion;

noReturn() { }
'noReturn' = noReturn;

badSize{T}(a:[T]i32) => a;
'badSize' = badSize{i32};

notConstant(a:i32) { x:[a]i32 = 5; 1 }
'notConstant'=notConstant;

addi32(a:i32, b:i32) => a+b;

wrongArgTypes(a: i64) => addi32(5, a);
'wrongArgTypes'=wrongArgTypes;

wrongArgCount1() => addi32(5);
'wrongArgCount1'=wrongArgCount1;

wrongArgCount2() => addi32(5,6,7);
'wrongArgCount2'=wrongArgCount2;

f{T}(a: 2*T) : T*2 => a;
'ok5'    =f{u8};
'ok6'    =f{i32};
'i128'   =f{i64};
'ok7'    =f{[4]u8};
'ok8'    =f{[4]i32};
'i128Vec'=f{[4]i64};

add{T}(a:T, b:T) => a+b;
'ok_add_i32'  = add{i32};
'ok_add_f32'  = add{f32};
'ok_add_f64'  = add{f64};
'ok_add_vi32' = add{[4]i32};
'ok_add_vf32' = add{[4]f32};
'ok_add_vf64' = add{[4]f64};
'addPtrs' = add{*i32};

three{T, fn}(a:T, b:T, c:T) => fn{T}(fn{T}(a, b), c);
'ok_add3i32' = three{i32, add};

threeB{T, fn}(a:T, b:T, c:T) => fn(fn(a, b), c);
'ok_add3i32B' = threeB{i32, add{i32}};

'functionType' = add{add};